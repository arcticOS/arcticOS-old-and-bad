arcticOS - A FOSS operating system for low-power phones. 
Designed to be compatible with Arduino & the Arduino IDE.

+=====================================================+
|                        NOTE:                        |
|   I am in the middle of rewriting the whole thing.  |
|     Most things don't work properly and lots of     |
|       features have been temporarily removed.       |
+=====================================================+

About arcticOS:
	arcticOS is a free (GPL3) operating system that is designed
	to run on low-power devices like microcontrollers and 
	dumbphones.
	
	By default, it has a minimalist phone UI that
	can be easily replaced or adapted into whatever you need - 
	whether that be a clock UI, touchscreen interface, or status
	monitor.
	
	It uses a unique, semi-cooperative multitasking scheme that is
	easy to work with, even on the low level.
	
Multitasking System Design:
	The multitasking system in arcticOS isn't like most multitasking
	systems. It is semi-cooperative, with 2 "threads" - the main thread,
	and the secondary thread.
	
	The Main Thread:
		The  main thread is where the majority of the code should be.
	
	The Secondary Thread:
		The secondary thread can contain many processes that may be too
		time-sensitive to be put inside the main thread. For example,
		if you have the main thread running a long operation, but you
		want the screen to show an animation to assure the user the
		software has not locked up, you could add a process to the 
		secondary thread that updates the screen with the next animation
		frame. This way, the animation will continuously update no 
		matter how long the operation on the main thread takes.
		
	Limitations and Potential Solutions:
		Long/Blocking Operations in the Secondary Thread:
			Some processes in the secondary thread may take longer than 
			expected, whether that be from a while loop that is taking
			too long, or just computationally demanding operations. This
			is problematic because there is no way to skip processes 
			that are running, and the main thread cannot continue until
			all processes in the secondary thread have finished.
			
			The obvious solution here would be to replace the 
			semi-cooperative multitasking with fully preemptive 
			multitasking, but the semi-cooperative method is much easier
			to port between systems because the only hardware-specific
			code required is just the code to register a timed IRQ. This
			is one of the big focuses in arcicOS, so below are some
			valid solutions:
			
			Solution 1 - Watchdog:
				Add a watchdog that will alert the developer through the
				debug interface that a process is taking too long in the
				secondary thread. This should help the developer fix the
				bug causing blocking.

				This is the solution that is currently implemented, but
				will likely be replaced by solution 2.

			Solution 2 - Advanced Watchdog:
				If the process takes too long (triggering a watchdog 
				"bark") then once it finishes, save the position in the
				process list and exit the secondary thread to allow the
				main thread to process further. When the secondary 
				thread resumes, skip to the saved position to finish
				executing the process list without a disruption in 
				process order.
			
				This is likely to be the solution that is used.
			
				Solution 2a - Aggresive Watchdog:
					If the Advanced Watchdog needs to activate multiple
					times for the same process, than "kill" that process
					by removing it from the process list.
